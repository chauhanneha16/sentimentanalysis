# -*- coding: utf-8 -*-
"""EMOTION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-T2niUIw4XGZZ7zJkKHhCyfJI_K6hW0g
"""

!pip install transformers
!pip install torch
!pip install datasets
!pip install translate
!pip install scikit-learn
!pip install matplotlib

import numpy as np
from sklearn.metrics import accuracy_score, confusion_matrix, roc_curve, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from datasets import load_dataset
import torch
import torch.nn.functional as F
from translate import Translator
from sklearn.model_selection import train_test_split

# Function to translate text in batches to manage memory usage
def translate_text_batch(texts, target_language, batch_size=100):
    translations = []
    translator = Translator(to_lang=target_language)
    for i in range(0, len(texts), batch_size):
        batch = texts[i:i + batch_size]
        try:
            batch_translations = [translator.translate(text) for text in batch]
            translations.extend(batch_translations)
        except Exception as e:
            print(f"Error translating batch to {target_language}: {e}")
            translations.extend([None] * len(batch))
    return translations

# Load GoEmotions dataset
dataset = load_dataset("go_emotions", split="train[:5000]")  # Use a subset for demonstration

# Mapping GoEmotions labels to custom emotion categories
emotion_mapping = {0: "admiration", 1: "amusement", 2: "anger", 3: "annoyance", 4: "approval", 5: "caring",
                   6: "confusion", 7: "curiosity", 8: "desire", 9: "disappointment", 10: "disapproval",
                   11: "disgust", 12: "embarrassment", 13: "excitement", 14: "fear", 15: "gratitude",
                   16: "grief", 17: "joy", 18: "love", 19: "nervousness", 20: "optimism", 21: "pride",
                   22: "realization", 23: "relief", 24: "remorse", 25: "sadness", 26: "surprise"}

# Define custom emotion labels for the emotions we are interested in
custom_emotion_labels = {"joy": 0, "sadness": 1, "anger": 2, "fear": 3, "surprise": 4}

# Filter sentences to only include those with emotions in custom_emotion_labels
filtered_sentences = {}
for example in dataset:
    try:
        emotion = emotion_mapping[example['labels'][0]]
        if emotion in custom_emotion_labels:
            filtered_sentences[example['text']] = example['labels'][0]
    except KeyError:
        continue

# Map the labels to custom emotion labels
filtered_sentences = {text: custom_emotion_labels[emotion_mapping[label]] for text, label in filtered_sentences.items()}

# Split into train and test sets
train_texts, test_texts, train_labels, test_labels = train_test_split(
    list(filtered_sentences.keys()),
    list(filtered_sentences.values()),
    test_size=0.2,
    random_state=42
)

# Translate test sentences
translations = {
    "Japanese": translate_text_batch(test_texts, 'ja'),
    "German": translate_text_batch(test_texts, 'de'),
    "Spanish": translate_text_batch(test_texts, 'es'),
    "Italian": translate_text_batch(test_texts, 'it')
}

# Print translations for verification
for lang, translated_texts in translations.items():
    print(f"\nTranslations in {lang}:")
    for original, translation in zip(test_texts, translated_texts):
        if translation:
            print(f"{original} -> {translation}")
        else:
            print(f"{original} -> Translation failed")

# Load multilingual emotion recognition models
model_names = {
    "RoBERTa": "j-hartmann/emotion-english-distilroberta-base",
    "DistilBERT": "bhadresh-savani/distilbert-base-uncased-emotion",
    "BERT": "finiteautomata/bertweet-base-sentiment-analysis",
    "XLM-RoBERTa": "joeddav/xlm-roberta-large-xnli"
}

huggingface_token = "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"

# Function to get emotion from text using the specified model
def get_emotion(text, tokenizer, model):
    inputs = tokenizer(text, return_tensors="pt", truncation=True)
    outputs = model(**inputs)
    probs = F.softmax(outputs.logits, dim=1)
    label = torch.argmax(probs).item()
    return label

# Map emotions to numerical labels for consistency
emotion_labels = {
    "joy": 0,
    "sadness": 1,
    "anger": 2,
    "fear": 3,
    "surprise": 4
}

# Predict emotions using the model
def predict_emotions(data, tokenizer, model):
    return [get_emotion(text, tokenizer, model) for text in data]

# Evaluate model
def evaluate_model(predictions, labels):
    acc = accuracy_score(labels, predictions)
    cm = confusion_matrix(labels, predictions, labels=list(emotion_labels.values()))
    return acc, cm

# Calculate EER with error handling for undefined metrics
def calculate_eer(labels, predictions):
    try:
        fpr, tpr, thresholds = roc_curve(labels, predictions, pos_label=1)
        eer = fpr[np.nanargmin(np.absolute((1 - tpr - fpr)))]
    except ValueError as e:
        print(f"Error calculating EER: {e}")
        eer = None
    return eer

# Compare models
results = {}
languages = ["Original", "Japanese", "German", "Spanish", "Italian"]

for model_name, model_path in model_names.items():
    tokenizer = AutoTokenizer.from_pretrained(model_path, token=huggingface_token)
    model = AutoModelForSequenceClassification.from_pretrained(model_path, token=huggingface_token)

    model_results = {}
    for lang in languages:
        if lang == "Original":
            data = test_texts
        else:
            data = translations[lang]
        predictions = predict_emotions(data, tokenizer, model)
        acc, cm = evaluate_model(predictions, test_labels)
        eer = calculate_eer(test_labels, predictions)
        model_results[lang] = {
            "accuracy": acc,
            "confusion_matrix": cm,
            "eer": eer
        }
    results[model_name] = model_results

# Print and visualize results
for model_name, model_results in results.items():
    print(f"\n{model_name} Results:")
    for lang, result in model_results.items():
        print(f"\n{lang} Results:")
        print(f"Accuracy: {result['accuracy']}")
        print(f"EER: {result['eer']}")
        disp = ConfusionMatrixDisplay(confusion_matrix=result['confusion_matrix'],
                                      display_labels=list(emotion_labels.keys()))
        disp.plot(cmap=plt.cm.Blues)
        plt.title(f"{model_name} - {lang} Confusion Matrix")
        plt.show()